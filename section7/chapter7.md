## 第7章：函数

函数是可以完成某些特定任务的，可重用的代码块。

举个例子，你有一块代码，可以让每条句子中的首字母大写。当你遇到一个新的字符串，需要使用这个功能的时候，你可以重新写这段代码（或者拷贝粘贴），虽然这可以达到目的，但这明显不是一种有效率的方式。

换一种方式，你可以把这段代码变成一个函数。这会让它更简单、快速的被重复使用。

之前我们已经看到过很多函数了。还记得str()，raw_input()和len()吧？他们是Python里预置的函数。你也可以创造自己的函数。

我们基于以下原因使用函数：

**可重用**	函数节省时间。函数使你不用一遍一遍的重新编写相同的代码。函数使编写程序变得更快、更容易。

**调试**	把一项任务的代码都组织在一起，容易发现程序的问题所在。

**模块化**	同一程序内的函数可以独立开发，其他人无需知道函数内部的运作机制。无论是在一个团队之中，还是开发开源软件，这都使共享代码变得更容易。

**扩展性**	在程序中可以大量的使用函数，而不必每次都要重写或复制代码。

这一章我们将会介绍如何编写和使用自己的函数。

一旦你适应了函数，我们将会接着介绍模块。模块是被打包在一起的，同一主题的函数的集合。

#### 7.1 Minecraft练习

函数使代码重用变得非常容易。你已经在之前的练习中用的了很多的Minecraft函数，在这一系列的练习里我们将创建自己的函数。

没想到吧，其实你一直在使用模块。

##### 7.1.1 森林

-----------------------------------

**知识与技巧**

本练习中，我们将练习的知识和技巧:

* 创建函数
* 调用函数
* 参数

-----------------------------------

一片森林的本质是一堆的树。为了在Minecraft里创建一片森林，我们将编写一个建造一棵树的函数，然后多次重复调用它，这样就可以建造森林了。

**指令**

下面是你将用到的基本代码：

	1. import mcpi.minecraft as minecraft
	2. mc = minecraft.Minecraft.create()
	3. 
	4. def growTree(x,y,z):
	5.     #把你的代码写在这里
	6. 
	7. pos = mc.player.getTilePos()
	8. x = pos.x
	9. y = pos.y
	10.z = pos.z
	11.
	12.growTree(x + 1, y, z)

这段代码里创建了growTree()函数，它接受三个代表坐标的参数。你的任务在填充这个函数的代码，让它在指定的坐标上创建一棵树。使用setBlock() 和setBlocks()函数做这事。

你可以多次调用这个函数，每次输入不同的坐标值，这样就可以建造多棵树。你可以在每次运行程序的时候，在玩家面前至少种植三行树，每行三棵。

**扩展练习**

* 随机树的高度、 距离和数量

##### 7.1.2 武装TNT

-----------------------------------

**知识与技巧**

本练习中，我们将练习的知识和技巧:

* 参数
* if语句

-----------------------------------

关于setBlock() 和 setBlocks()函数，有一些你不知道的事情。他们有一个扩展参数。之前你通过这些函数的参数，设置坐标和块类型。他们还有一个扩展参数，可以设置块的状态。

每个块有16中状态。比如羊毛，每种状态都对应不同的颜色。TNT（块id是64）在状态值等于1时，就会爆炸。

每个块有16个状态，但不是每种状态都不相同。用这些函数放在最后的扩展参数，可以设置块状态。下面的代码就是创造武装TNT：

	4. mc.setBlock(10, 3, -4, 46, 1)
	5.
	6. mc.setBlocks(11, 3, -4, 20, 6, -8, 46, 1)

你的任务是检查某些块是否是TNT，如果是，引爆它！

**指令**

使用下面的程序骨架编写你的代码：

	1. # 创建函数，用坐标当参数
	2. # 得到块类型
	3. # 检查块类型是否是 TNT
	4. # 如果是，创建一个要爆炸的TNT （state.=1）
	5. # 如果不是打印 ”not TNT”

一旦你完成了检查特定位置是否是TNT的函数，你可以设计一些测试程序，调用这个函数，看它是否工作正常。一定要分别使用TNT块和非TNT块测试这个函数。

有一种测试方法是把TNT放在不同的地方，然后用这些坐标当参数调用函数。你也可以把玩家的位置坐标传给这个函数。这样你可以站在TNT上测试。

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**警报箱**

**注意**: 一旦你创建了一个要爆炸的TNT，你必须点击它使他爆炸。不要在多玩家模式下测试，因为setBlock()在这个模式下不能正常运行。 

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**扩展练习**

* 试着找出每个块不同的状态
* 递增状态，而不是仅仅将其设置为1

##### 7.1.3 羊毛的颜色

-----------------------------------

**知识与技巧**

本练习中，我们将练习的知识和技巧:

* 参数
* 函数
* 返回值
* if语句
* elif语句
* else语句

-----------------------------------

羊毛（块id是35）由于有不同的颜色，所以在Minecraft中有很多的用途。上一个练习里提到了，通过设置setBlock() 和 setBlocks()函数里的扩展参数，羊毛可以有16中不同的颜色。然而记住这些状态对应的颜色是很困难的，为什么我们不开发一个程序，让程序来帮助我们记忆这些状态。

**指令**
你需要在这里做一些判断工作。首先最重要的是，你需要找出每种颜色对应的状态。你可以用任何你喜欢的方式，实现这一目标。这儿有个例子：粉色对应状态是6。

如果你已经找到了所有的对应关系，那么创造一个函数，用颜色的字符串做参数，返回此颜色对应的状态值。例如，传入参数“pink”（粉色），返回值就是6。每种颜色都必须返回正确的值。

如果参数不正确，你可以发送一些有用的信息到聊天窗口。

##### 7.1.4 龟

-----------------------------------

**知识与技巧**

本练习中，我们将练习的知识和技巧:

* 参数
* 函数
* 全局变量

-----------------------------------

Logo是一门为学习而设计的编程语言。在Logo里，你可以控制屏幕上的小海龟画线。你可以通过给发送命令，例如forward 5 （向前 5），使海龟移动5像素。类似的backwards 5会让海龟向后移动5像素。在这个练习里我们会创建一个程序，类似Logo里的海龟。

这个练习会用的一个Codecademy.com里没有介绍的概念：全局标量。在函数里修改一个变量的时候，需要知道，这个变量是只在函数里有效的局部变量，还是在整个程序里都有效的全局变量。如果这个变量是全局变量，在函数里修改它的时候，你需要在这个变量前面加上**global**关键字。例如：

	1. x = 10
	2.
	3. def doubleX()
	4.     global x
	5.     x = x * 2

**指令**

创建一个程序，满足以下需求：

* forward函数使玩家沿着x轴，向前移动一些块的距离。
* backward函数使玩家沿着x轴，向后移动一些块的距离。
* right函数使玩家沿着z轴的正向，移动一些块的距离。
* left函数使玩家沿着z轴的负向，移动一些块的距离。
* up函数使玩家沿着y轴，上升一些块的距离。
* down函数使玩家沿着y轴，下降一些块的距离。
* penDown函数设置变量draw为true。
* penUp设置变量draw为false。

对于所有上述函数，必须满足以下条件：

* 如果变量draw为ture，移动玩家将创建块。
* 如果变量draw为false，移动玩家不会创建块。
* 一个函数运行后，它必须先等待0.1秒，然后再移动。

编写代码完成以上的函数后，调用这些函数画出下面这些图形：

1. 正方形
2. 三条平行线
3. 一张笑脸

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**警报箱**

**注意**: 如果你熟悉Logo语言，你会注意到我们的实现方式和它是不一样的。Logo中通过角度来实现左转和右转。我们的程序做不到这一点。我们的左转和右转实际上是让海龟按方向移动。

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**扩展练习**

* 增加一个方法改变画笔的颜色
* 增加一个橡皮模式，擦除块，而不是放置块

##### 7.1.5 导入块模块

让我们用简单的任务结束练习。这个**import**关键字允许你使用其他的Python模块来扩展你程序的能力。实际上你之前已经用到它了。在每个Minecraft练习程序里，都有这么一行用到了**import**关键字：

	1. import mcpi.minecraft as minecraft

这个被引用的模块，允许你的程序和Minecraft交互。其他和Minecraft一起的模块还有，block模块。之前你都用整数代表块的类型。block模块可以让你用变量代替整数。例如，下面的代码中，用AIR变量代替整数0来代表空气模块：

	1. import mcpi.block as block
	2. import mcpi.minecraft as minecraft
	3. mc = minecraft.Minecraft.create()
	4.
	5. mc.setBlock(0, 0, 0, block.AIR)

用变量代替整数，可读性更强，更便于记忆。

**指令**

为了使用block模块里的变量，你需要先找到他们。寻找包含blcok模块的文件。提示：名为block.py的文件，在mcpi目录下的某个地方。

#### 7.2 函数语法

现在我们知道，函数是很有用的，让我们看看如何使用它。

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**函数定义**

*声明*

函数是可重用的代码块。包括了一个**def**关键字，一个函数的名字和参数

**表达式**

	1. def functionName(arguments):
	2.     #函数的代码放在这里

**语句**

	1. def addTwoNumbers(number1, number2):
	2.     sum = number1 + number2
	3.     print str(sum)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

所有的函数定义语句都包括以下4部分：

	1. def 关键字
	2. 一个函数名（在调用的时候，用来识别函数）
	3. 包在括号()里的参数（可选），以及括号之后冒号
	4. 函数代码体

**def**关键字是单词define的缩写，这是告诉Python，我要开始写函数了。

函数的名字是用来区别函数的。每个函数都要有不同的名字，否则Python不知道你想调用哪个代码块。下面的代码里，codeName就是函数名：

	1. def codeName(agentName):
	2.     print ”Code Name: ” + agentName

参数是调用函数时，传递给函数的值。他们告诉函数，在函数被调用的时候，这些变量的值会从外面传进来。在上面的例子中agentName就是一个参数。多个参数用逗号分隔。

一个函数不是必须有参数。你可以留一个空的括号，表示这个函数不接受参数。例如下面的代码不接受任何参数，直接打印“Hello”：

	1. def printHello():
	2. print ”Hello”

别忘了在这一行的末尾加上冒号。冒号后面的那些缩进行，是函数的主体部分，是函数被调用时要运行的代码。

函数的主体部分，会缩进1个tab或者4个空格，两者不能混合。一个函数可以包含任意多的语句。它们也可以包含if语句等之前你学过的语句。完成函数代码后，就停止缩进。

#### 7.2.1 调用函数

使用函数一般被称作调用函数，你需要写上函数名，需要的话，在括号里加上参数。

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**函数调用**

*表达式*

为了在代码里使用函数，必须调用它。调用语句应该包括这个函数名，以及需要的参数。多个参数用逗号分隔。

**表达式**

	1. functionName(arguments)

**语句**

	1. addTwoNumbers(5, 3)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

为了调用我们之前定义的codeName() 和 printHello() 函数，应该使用如下代码：

	1. codeName(”Solid Snake”)
	2.
	3. printHello()

#### 7.2.2 返回

有两种类型的函数，一种返回值，另一种不返回值。到目前为止，我们创建的函数都不返回值。现在让我们看一个返回值的函数。

函数返回值用处很大。比如我们一个心率监测器监控人的心跳。我们可以一个函数，返回监测器里的数据。没有返回操作的话，我们就不能访问监测器里的数据了。

现在，我们自己来创建一个能返回值的函数。例如，下面的函数在参数people上加2：

	1. def plusTwo(people):
	2.     return people + 2

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**return**

*语句*

return语句用在函数里，用来返回一个值。它返回值到函数被调用的位置，并且返回的值，可以像其他数据那样被使用。

**表达式**

	1. def functionName(arguments):
	2.     #body of function
	3.     return variable

**语句**

	1. def addFullStop(string):
	2.     return string + ”.”
	3
	4 #调用这个函数
	5. sentence = addFullStop(”Hello”)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

使用能返回值的函数，你可以在期望获得值的位置调用它。例如，我们调用plusTwo()：

	1. total = plusTwo(6) #value will be 8

函数返回的值可以赋给变量。他们可以在你希望的任何地方使用。

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**警报箱**

**注意**:return运算符决定着一个函数是否有返回值。没有返回值的函数不能给别的变量赋值。这时函数本身构成了一条语句。

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

#### 7.2.3 多参数

我们已经看过了，在函数里可以用逗号分隔的多个参数。当你不知道函数有多少个参数的时候，改如何定义函数呢？

还好，Python 提供了非常方便的方式来接受数目不详参数: 在定义函数的时候，把 * 号加在参数前面。

我们有一个程序，打印接收到的值：

	1. def createList(*items):
	2.     print items
	
它可以这样被调用：
	
	1. createList(”Grover”, ”Elmo”, ”Snuffy”)

或者这样：	

	1. createList(”Grover”)

还可以这样：

	1. createList(”Hawk”, ”Fox”, ”Snake”, ”Hippo”,”Monkey”, ”Frog”, ”Snake”, ”Jim”)

\* 号的作用实际上是告诉Python，函数将接收一个不确定成员数的列表。我们将在列表那章学习列表的相关知识，到那时候 \* 操作符将更加有用。

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**参数不限数量 ***

*操作符*

在参数前使用\* 操作符，就是告诉函数准备接收任意数量的参数

**表达式**

	1. def functionName(*arguments):
	2.     #body of function
	3.     #optional return variable

**语句**

	1. def printMembers(*members):
	2.     print members
	3.
	4. printMembers(”Fox”, ”Slippy”, ”Falco”, ”Peppy”)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

#### 7.3 模块

模块是可重用的函数集合。函数被打包进模块，是为了让功能相似的函数更容易被一起共享。

例如，你可能有一个处理图片的模块。那么这个模块很可能包括了加载，保存，修改图片的功能。

在这一章节里，我们将用我们熟悉的方式，在我们自己的程序里引用和使用模块。

#### 7.3.1 Import

为了使用一个模块中的函数，我们需要把模块引入我们的程序。

math模块是用来处理数学问题的，下面我们演示如何引入它：

	1. import math

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**import**

*语句*

在Python程序中引入模块

**表达式**

	1. import moduleName
	2. #使用一个模块里的函数
	3. moduleName.function(arguments)

**语句**

	1. import math
	2. #使用一个模块里的函数
	3. print math.sqrt(4)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

一旦我们把模块引入程序，就可以在程序中使用这个模块的函数了。引入后，通过模块名加句号（.）加函数名来调用模块中的函数。

例如，开方(sqrt)是math模块里的一个方法：

	1. print math.sqrt(4) #prints 2
	
我们可以使用pydoc模块来找出一个模块里的所有函数。pydoc模块包含了其他模块的所有文档。引入pydoc模块，调用help()函数，就可以访问这些文档。把你想要访问的模块名，当成字符串传给help()函数。这里有个访问math模块文档的例子：

	1. import pydoc
	2. pydoc.help(”math”)

#### 7.3.2 from

有时候你只是需要模块里的一个函数，这时就可以使用from关键字。from允许你不加模块名和点号就可以调用函数，也就是说你不用写成这样： module.function()，可以直接写成这样： function()。

math模块的例子可以改成这样：

	1. from math import sqrt
	2. print sqrt(4) # prints 2

使用**from**关键字你可以从模块中引入多个函数。多个函数之间用逗号分隔。

	1. from math import sqrt, sin

#### 7.3.3 引入所有 *

你也可以用引入模块里的所有函数。只需要把 * 放在函数名的位置：

	1. from module import *	

这样就可以直接调用模块里的函数，不用在前面加函数名和点了：

	1. from math import *
	2. print sqrt(4)
	3. print sin(6)
	
这里有使用 * 号的风险：

 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**警报箱**

**注意**:有时候不同模块可能包含了相同名字的函数。发生这种情况时Python就会疑惑。这个时候，应该使用from语句单独引入需要的方法。
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

因此，引入模块所有的函数是不推荐的，除非你清楚这些模块之间不会发生冲突。

#### 7.4 内置函数

根据Codecademy.com的内容，我们介绍四个内置函数：

* 	max()
* 	min()
* 	abs()
* 	type()

#### 7.4.1 max()

max()函数返回的参数列表中的最高值（最大值）：

	1. highest = max(7,9,2,3) #value of 9

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**max()**

*函数*

返回的参数列表中的最高值（最大值）。

**表达式**

	1. max(values)

**语句**

	1. highest = max(10, 100, 63)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

#### 7.4.2 min()

min()函数返回的参数列表中的最低值（最小值）：

	1. lowest = min(7,9,2,3) #value of 2

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**min()**

*函数*

返回的参数列表中的最低值（最小值）。

**表达式**

	1. min(values)

**语句**

	1. lowest = min(10, 100, 63)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

#### 7.4.3 abs()

abs()函数返回绝对值：

	1. distance = abs(-231) #value of 231

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**abs()**

*函数*

接收一个数字做参数，如果这个数字小于0的话，返回这个数字的绝对值。它能使负数变正数。

**表达式**

	1. abs(value)

**语句**

	1. absolute = abs(-100)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

#### 7.4.4 type()

type()函数返回变量的类型。

有很多场合，你需要找出变量的数据类型。你可以使用type()函数达到目的。例如：

	1. print type(19)

上面的代码将会返回变量的数据类型，这样的格式：\<type ’int’\>。type()函数在检查两个变量是否是相同的数据类型时非常管用。
 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**type()**

*函数*

接收一个参数，返回这个参数的数据类型

**表达式**

	1. type(value)

**语句**

	1. userInput = input(”Enter a value: ”)
	2. print type(userInput)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

